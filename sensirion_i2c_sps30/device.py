#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.3.3
# Product:       sps30
# Model-Version: 1.0.1
#
"""
The class Sps30DeviceBase implements the low level interface of the sensor.
The class Sps30Device extends the Sps30DeviceBase. It provides additional functions to ease the use of the
sensor.
"""

from sensirion_driver_adapters.transfer import execute_transfer
from sensirion_driver_support_types.mixin_access import MixinAccess
from sensirion_i2c_sps30.commands import (ClearDeviceStatusRegister, DeviceReset, ReadAutoCleaningInterval,
                                          ReadDataReadyFlag, ReadDeviceStatusRegister, ReadFirmwareVersion,
                                          ReadMeasurementValuesFloat, ReadMeasurementValuesUint16, ReadProductType,
                                          ReadSerialNumber, Sleep, StartFanCleaning, StartMeasurement, StopMeasurement,
                                          WakeUp, WriteAutoCleaningInterval)


class Sps30DeviceBase:
    """Low level API implementation of SPS30"""

    def __init__(self, channel):
        self._channel = channel

    @property
    def channel(self):
        return self._channel

    def start_measurement(self, measurement_output_format):
        """
        Starts the measurement. After power up, the module is in Idle-Mode. Before any measurement values can be read, the
        Measurement-Mode needs to be started using this command.

        :param measurement_output_format:
            Possible enum values: output_format_float, output_format_uint16

        .. note::
            This command can only be executed in Idle-Mode.

        :Example:
            .. code-block:: python

                sensor.start_measurement(OutputFormat(1280))

        """
        transfer = StartMeasurement(measurement_output_format)
        return execute_transfer(self._channel, transfer)

    def stop_measurement(self):
        """Use this command to return to the Idle-Mode."""
        transfer = StopMeasurement()
        return execute_transfer(self._channel, transfer)

    def read_data_ready_flag(self):
        """
        This command can be used for polling to find out when new measurements are available. The pointer address only has
        to be set once. Repeated read requests get the status of the Data-Ready Flag.

        :return data_ready_flag:
            0x0000: no new measurements available
            0x0001: new measurements ready to read
        """
        transfer = ReadDataReadyFlag()
        return execute_transfer(self._channel, transfer)[0]

    def read_measurement_values_uint16(self):
        """
        Reads the measured values from the sensor module and resets the “Data-Ready Flag”. If the sensor module is in
        Measurement-Mode, an updated measurement value is provided every second and the “Data-Ready Flag” is set. If no
        synchronized readout is desired, the “Data-Ready Flag” can be ignored. The command “Read Measured Values” always
        returns the latest measured values.

        :return mc_1p0:
            Mass Concentration PM1.0 [µg/m³]
        :return mc_2p5:
            Mass Concentration PM2.5 [µg/m³]
        :return mc_4p0:
            Mass Concentration PM4.0 [µg/m³]
        :return mc_10p0:
            Mass Concentration PM10.0 [µg/m³]
        :return nc_0p5:
            Number Concentration PM0.5 [#/cm³]
        :return nc_1p0:
            Number Concentration PM1.0 [#/cm³]
        :return nc_2p5:
            Number Concentration PM2.5 [#/cm³]
        :return nc_4p0:
            Number Concentration PM4.0 [#/cm³]
        :return nc_10p0:
            Number Concentration PM10.0 [#/cm³]
        :return typical_particle_size:
            Typical Particle Size [µm]

        .. note::
            Use this function when the measurement output format is configured to: "Big-endian unsigned 16-bit integer values"
        """
        transfer = ReadMeasurementValuesUint16()
        return execute_transfer(self._channel, transfer)

    def read_measurement_values_float(self):
        """
        Reads the measured values from the sensor module and resets the “Data-Ready Flag”. If the sensor module is in
        Measurement-Mode, an updated measurement value is provided every second and the “Data-Ready Flag” is set. If no
        synchronized readout is desired, the “Data-Ready Flag” can be ignored. The command “Read Measured Values” always
        returns the latest measured values.

        :return mc_1p0:
            Mass Concentration PM1.0 [µg/m³]
        :return mc_2p5:
            Mass Concentration PM2.5 [µg/m³]
        :return mc_4p0:
            Mass Concentration PM4.0 [µg/m³]
        :return mc_10p0:
            Mass Concentration PM10.0 [µg/m³]
        :return nc_0p5:
            Number Concentration PM0.5 [#/cm³]
        :return nc_1p0:
            Number Concentration PM1.0 [#/cm³]
        :return nc_2p5:
            Number Concentration PM2.5 [#/cm³]
        :return nc_4p0:
            Number Concentration PM4.0 [#/cm³]
        :return nc_10p0:
            Number Concentration PM10.0 [#/cm³]
        :return typical_particle_size:
            Typical Particle Size [µm]

        .. note::
            Use this function when the measurement output format is configured to: "Big-endian IEEE754 float values"
        """
        transfer = ReadMeasurementValuesFloat()
        return execute_transfer(self._channel, transfer)

    def sleep(self):
        """
        Enters the Sleep-Mode with minimum power consumption. This will also deactivate the I2C interface.

        .. note::
            This command can only be executed in Idle-Mode.
        """
        transfer = Sleep()
        return execute_transfer(self._channel, transfer)

    def wake_up(self):
        """
        In Sleep-Mode the I2C interface is disabled and must first be activated by sending a low pulse on the SDA line.
        A low pulse can be generated by sending a I2C-Start-Condition followed by a Stop-Condition.
        If then a Wake-up command follows within 100ms, the module will switch on again and is ready for further commands in
        the Idle-Mode. If the low pulse is not followed by the Wake-up command, the microcontroller returns after 100ms to
        Sleep-Mode and the interface is deactivated again.

        Alternatively, if the software implementation does not allow to send a I2C-Start-Condition followed by a Stop-Condition,
        the Wake-up command can be sent twice in succession. In this case the first Wake-up command is ignored, but causes
        the interface to be activated.
        """
        transfer = WakeUp()
        return execute_transfer(self._channel, transfer)

    def start_fan_cleaning(self):
        """
        Starts fan cleaning manually

        .. note::
            This command can only be executed in Measurement-Mode.
        """
        transfer = StartFanCleaning()
        return execute_transfer(self._channel, transfer)

    def read_auto_cleaning_interval(self):
        """
        Reads auto cleaning interval of the periodic fan-cleaning

        :return auto_cleaning_interval:
            Interval in seconds
        """
        transfer = ReadAutoCleaningInterval()
        return execute_transfer(self._channel, transfer)[0]

    def write_auto_cleaning_interval(self, auto_cleaning_interval):
        """
        Writes auto cleaning interval of the periodic fan-cleaning

        :param auto_cleaning_interval:
            Interval in seconds

        .. note::
            For FW Version < 2.2: After writing a new interval, this will be activated immediately. However, if the interval register
            is read out after setting the new value, the previous value is returned until the next start/reset of the sensor module.

        :Example:
            .. code-block:: python

                sensor.write_auto_cleaning_interval(604800)

        """
        transfer = WriteAutoCleaningInterval(auto_cleaning_interval)
        return execute_transfer(self._channel, transfer)

    def read_product_type(self):
        """
        This command returns the product type. It is defined as a string value with a length of 8 ASCII
        characters (excluding terminating null-character)

        :return product_type:
            8-byte ASCII string
        """
        transfer = ReadProductType()
        return execute_transfer(self._channel, transfer)[0]

    def read_serial_number(self):
        """
        This command returns the serial number. It is defined as a string value with a maximum length of 32 ASCII
        characters (including terminating null-character)

        :return serial_number:
            32-byte ASCII string
        """
        transfer = ReadSerialNumber()
        return execute_transfer(self._channel, transfer)[0]

    def read_firmware_version(self):
        """
        Gets firmware major.minor firmware version.

        :return major_version:

        :return minor_version:

        """
        transfer = ReadFirmwareVersion()
        return execute_transfer(self._channel, transfer)

    def read_device_status_register(self):
        """
        Use this command to read the device status register. For more details, check explanations given in chapter 4.4 of the datasheet.

        :return device_status:

        """
        transfer = ReadDeviceStatusRegister()
        return execute_transfer(self._channel, transfer)[0]

    def clear_device_status_register(self):
        """Use this command to clear the device status register. For more details, check explanations given in chapter 4.4 of the datasheet."""
        transfer = ClearDeviceStatusRegister()
        return execute_transfer(self._channel, transfer)

    def device_reset(self):
        """
        Device software reset command. After calling this command, the module is in the same state as after a power reset.

        .. note::
            To perform a reset when the sensor is in sleep mode, it is required to send first a wake-up sequence to activate
            the interface.
        """
        transfer = DeviceReset()
        return execute_transfer(self._channel, transfer)


class Sps30Device(Sps30DeviceBase):
    """Driver class implementation of SPS30"""

    #: Access to base class
    sps30 = MixinAccess()

    def __init__(self, channel):
        super().__init__(channel)

    def wake_up_sequence(self):
        """Fully wake up the device"""
        self.sps30.wake_up()
        self.sps30.wake_up()
